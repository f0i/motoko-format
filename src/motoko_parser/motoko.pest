// helper
any_inline = @{ !NEWLINE ~ ANY }
space = @{ " " | "\t" }
EOL = _{ !(!NEWLINE) | EOI }

WHITESPACE = @{ ( space | NEWLINE )+ }
COMMENT = @{ Comment }
ShouldNewline = ${ (WHITESPACE | Comment)* }

// Lit
Lit = ${ Float | Nat | Char | Text }
Nat = ${ "0x" ~ HexNum | Num }
Num = @{ ASCII_DIGIT ~ ( "_"? ~ ASCII_DIGIT )* }
HexNum = @{ ASCII_HEX_DIGIT ~ ( "_"? ~ ASCII_HEX_DIGIT )* }
Sign = @{ "-" }

Frac = @{ Num }
HexFrac = @{ HexNum }
Float = @{
  Num ~ "." ~ Frac?
  | Num ~ ("." ~ Frac?)? ~ ("e" | "E") ~ Sign? ~ Num
  | HexNum ~ "." ~ HexFrac?
  | "0x" ~ HexNum ~ ("." ~ HexFrac?)? ~ ("p" | "P") ~ Sign? ~ Num
}

Escape = { "n" | "r" | "t" | "\\" | "\'" | "\"" }

Character = @{ 
    "\\" ~ Escape
    | "\\" ~ ASCII_HEX_DIGIT ~ ASCII_HEX_DIGIT
    | "\\{" ~ HexNum ~ "}"
    | !("\\") ~ any_inline
}

Char = @{ "'" ~ (!"'" ~ Character) ~ "'" }
Text = @{ "\"" ~ (!"\"" ~ Character)* ~ "\"" } // TODO: check "'" and '"' and ''' and """ in motoko



Id = @{ ASCII_ALPHA ~ ( ASCII_ALPHANUMERIC | "_" )* }

// comments
Comment = ${ ( DocComment | LineComment | BlockComment ) ~ SpacedComment? }
SpacedComment = ${ WHITESPACE? ~ Comment }
DocComment = ${ ("/// " ~ DocCommentContent ~ EOL)+ }
LineComment = ${ "//"  ~ LineCommentContent ~ EOL }
BlockComment = ${ "/*" ~ " "? ~ BlockCommentContent ~ "*/" }
DocCommentContent = @{ any_inline* }
LineCommentContent = @{ any_inline* }
BlockCommentContent = @{
    ((!("*/" | "/*") ~ ANY) | BlockComment)* // allow nested comments
}

// Syntax from grammar.txt
Motoko = {
  Header ~ Program ~ EOI
}
Header = ${
  SOI
  ~ WHITESPACE*
  ~ (Comment ~ ShouldNewline)?
}
Program = {
  //List
  CompleteImport*
  ~ CompleteDeclaration*
}


CompleteImport = { Import ~ EndOfImport }
EndOfImport = ${ Semicolon ~ ShouldNewline }
EndOfDeclaration = ${
  ( Semicolon | EOI )
  ~ ShouldNewline
}

CompleteDeclaration = { Declaration ~ EndOfDeclaration }


InvalidPart = { (!";" ~ ANY)+ ~ ";"?}

Semicolon = @{ ";" }
EqualSign = @{ "=" }
Colon = @{ ";" }

// Imports
Import = { "import" ~ PatternNullary ~ EqualSign? ~ Text }
PatternNullary = {
  "{" ~ /*List*/ (PatternField  ~ (Semicolon ~ PatternField)*)? ~ "}"
  | PatternPlain
}
PatternField = {
  Id ~ (":" ~ Type)? ~ ("=" ~ Pattern)?
}
Pattern = { PatternBin }
PatternBin = {
  PatternUn ~ ("or" ~ PatternBin)* ~ (":" ~ Type)* 
}
PatternPlain = {
  "_"
  | "(" ~ /*List*/(PatternField ~ (";" ~ PatternField)*)? ~ ")"
  | Lit
  | Id
}
PatternUn = {
  "#" ~ Id ~ PatternNullary?
  | "?" ~ PatternUn
  | UnOp ~ Lit
  | PatternNullary
}

UnOp = @{ "+" | "-" | "^" } 

Type = {
    TypeNoBin ~ "and" ~ Type
    | TypeNoBin ~ "or" ~ Type
    | TypeNoBin
}

TypeNoBin = {
    FuncSortOpt ~ ("<" ~/*List*/(TypeBind ~ ("," ~ TypeBind)*)? ~ ">")? ~ TypeUn ~ "->" ~ TypeNoBin
    | TypePre
}

FuncSortOpt = { "shared" ~ (space ~ "query")? | "query"?}

TypePre = {
    "async" ~ TypePre
    | ObjSort ~ TypObj
    | TypeUn
} 

ObjSort = { "object" | "actor" | "module" }

TypeBind = { Id ~ ("<:" ~ Type)? }

TypeUn = {
  "?" ~ TypeUn
  | TypeNullary
}

TypeNullary = {
    "(" ~ /*List*/(TypeItem ~ ("," ~ TypeItem)*)? ~ ")"
    | "[" ~ "var"? ~ Type ~ "]"
    //TODO: | <typ_variant>
    //TODO: | <typ_obj>
    | Id ~ ("." ~ Id)* ~ TypeArgs?
} 
TypeItem = { (Id ~ ":")? ~ Type }

TypeArgs = {
  "<" ~ /*List*/(Type ~ ("," ~ Type)*)? ~ ">"
}

TypObj = {
    "{" ~ /*List*/(TypeField ~ (";" ~ TypeField)*)? ~ "}"
} 

TypeField = {
  "var"? ~ Id ~ ":" ~ Type
  | Id ~ TypeBindList? ~ TypeNullary ~ ":" ~ Type
}

TypeBindList = {
  "<" ~ /*List*/(TypeBind ~ ("," ~  TypeBind)*)? ~ ">"
}

Declaration = {
  ( DeclarationVar
  | DeclarationNonVar
  | ExpNonDec
  ) ~ COMMENT? // hack to collect all tailing whitespace and comments
}

DeclarationVar = {
  "var" ~ Id ~ (":" ~ Type)? ~ "=" ~ Exp
}

DeclarationNonVar = {
  "let" ~ Pattern ~ "=" ~ Exp
  | "type" ~ Id ~ TypeBindList? ~ "=" ~ Type
  | ObjSort ~ Id? ~ "="? ~ ObjBody
  | SharedPatternOpt ~ "func" ~ Id? ~ TypeBindList? ~ PatternPlain ~ (":" ~ Type)? ~ FuncBody
  //TODO
}

SharedPatternOpt = {
    "shared" ~ "query"? ~ PatternPlain?
    | "query" ~ PatternPlain
    | "query"?
}

FuncBody = {
  "=" ~ Exp
  | Block
}

Block = {
  "{" ~ /*List*/(Declaration ~ (";" ~ Declaration)*)? ~ "}"
}

ObjBody = {
  "{" ~ /*List*/(DeclarationField ~ (";" ~ DeclarationField)*)? ~ "}"
}
DeclarationField = { Visibility ~ Stability ~ Declaration }
Visibility = {
    ("private" | "public" | "system")?
}
Stability = {
  ("flexible" | "stable")?
}

Exp = {
  DeclarationVar
  | ExpNonVar
}

ExpNonVar = {
  ExpNonDec
  | DeclarationNonVar
}

ExpNonDec = {
  ExpBin ~ ":=" ~ Exp
  //| "assert" <exp_nest>
  //| "async" <exp_nest>
  //| "await" <exp_nest>
  //| "break" <id> <exp_nullary>?
  //| "continue" <id>
  //| "debug" <exp_nest>
  //| "do" ~ "?" ~ <block>
  //| "do" <block>
  //| "for" "(" <pat> "in" <exp> ")" <exp_nest>
  //| "if" <exp_nullary> <exp_nest>
  //| "if" <exp_nullary> <exp_nest> "else" <exp_nest>
  //| "ignore" <exp_nest>
  //| "label" <id> (":" <typ>)? <exp_nest>
  //| "loop" <exp_nest>
  //| "loop" <exp_nest> "while" <exp_nest>
  | "return" ~ Exp
  //| "switch" <exp_nullary> "{" <list(<case>, ";")> "}"
  //| "throw" <exp_nest>
  //| "try" <exp_nest> <catch>
  //| "while" <exp_nullary> <exp_nest>
  | ExpBin ~ ":=" ~ Exp
  | ExpBin ~ BinAssign ~ Exp
  | ExpBin
  //TODO
}

BinAssign = @{
  "%="
  | "&="
  | "*%="
  | "**%="
  | "**-"
  | "*="
  | "+%="
  | "+="
  | "-%="
  | "-="
  | "/="
  | "<<="
  | "<<>="
  | "<>>="
  | ">>="
  | "@="
  | "^="
  | "|="
}

ExpUn = {
    "?" ~ ExpUn
    | "actor" ~ ExpPlain
    | "not" ~ ExpUn
    | "debug_show" ~ ExpUn
    | "to_candid" ~ ExpList
    | "from_candid" ~ ExpUn
    | "#" ~ Id ~ ExpNullary?
    | UnOp ~ ExpUn
    | UnAssign ~ ExpUn
    | ExpPost
}

ExpPost = {
  ("[" ~ "var"? ~ /*List*/(ExpNonVar ~ ("," ~ ExpNonVar)*)? ~ "]"
  | ExpNullary
  )
  ~ ( ExpPost
    | "[" ~ Exp ~ "]"
    | "." ~ Nat
    | "." ~ Id
    | ("<" ~ /*List*/(Type ~("," ~ Type)*)? ~ ">")? ~ ExpNullary
    | BANG
  )?
}

BANG = @{ "!" }

ExpNullary = {
  ExpObj | ExpPlain | Id
}

ExpObj = {
  "{" ~ /*List*/(ExpField ~ (";" ~ ExpField)*)? ~ "}"
}

ExpField = {
  "var"? ~ Id ~ (":" ~Type)? ~ ("=" ~ Exp)?
}

UnAssign = { "+=" | "-=" | "^=" }

ExpList = {
  "(" ~ /*List*/ (Exp ~ ("," ~ Exp)*)? ~ ")"
}

ExpPlain = {
  ExpList
  | Lit
}

ExpBin = {
  ExpUn ~ (
    "and" ~ ExpBin
    | "or" ~ ExpBin
    | ":" ~ ExpBin
    | BinOp ~ ExpBin
    //| RelOp ~ ExpBin
  )?
}

BinOp = {
    "+"
    | "#"
    | "%"
    | "&"
    | "*"
    | "*%"
    | "**%"
    | "**"
    | "+%"
    | "-%"
    | "-"
    | "/"
    | "<<>"
    | "<<"
    | "<>>"
    | ">>" /* can't match leading space */
    | "^"
    | "|"
}

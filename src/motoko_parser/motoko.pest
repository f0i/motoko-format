// helper
any_inline = @{ !NEWLINE ~ ANY }
space = @{ " " | "\t" }
EOL = _{ !(!NEWLINE) | EOI }

WHITESPACE = @{ ( space | NEWLINE )+ }
COMMENT = @{ Comment }
ShouldNewline = ${ (WHITESPACE | Comment)* }

// Lit
Lit = ${ Float | Nat | Char | Text }
Nat = ${ "0x" ~ HexNum | Num }
Num = @{ ASCII_DIGIT ~ ( "_"? ~ ASCII_DIGIT )* }
HexNum = @{ ASCII_HEX_DIGIT ~ ( "_"? ~ ASCII_HEX_DIGIT )* }
Sign = @{ "-" }

Frac = @{ Num }
HexFrac = @{ HexNum }
Float = @{
  Num ~ "." ~ Frac?
  | Num ~ ("." ~ Frac?)? ~ ("e" | "E") ~ Sign? ~ Num
  | HexNum ~ "." ~ HexFrac?
  | "0x" ~ HexNum ~ ("." ~ HexFrac?)? ~ ("p" | "P") ~ Sign? ~ Num
}

Escape = @{ "n" | "r" | "t" | "\\" | "\'" | "\"" }

Character = @{ 
    "\\" ~ Escape
    | "\\" ~ ASCII_HEX_DIGIT ~ ASCII_HEX_DIGIT
    | "\\{" ~ HexNum ~ "}"
    | !("\\") ~ any_inline
}

Char = @{ "'" ~ (!"'" ~ Character) ~ "'" }
Text = @{ "\"" ~ (!"\"" ~ Character)* ~ "\"" }

Id = @{ !Keyword ~ IdStart ~ IdContinue* }
IdStart = @{ ASCII_ALPHA }
IdContinue = @{ ASCII_ALPHANUMERIC | "_" }

// comments
Comment = ${ ( DocComment | LineComment | BlockComment ) ~ SpacedComment? }
SpacedComment = ${ WHITESPACE? ~ Comment }
DocComment = ${ ("/// " ~ DocCommentContent ~ EOL)+ }
LineComment = ${ "//"  ~ LineCommentContent ~ EOL }
BlockComment = ${ "/*" ~ " "? ~ BlockCommentContent ~ "*/" }
DocCommentContent = @{ any_inline* }
LineCommentContent = @{ any_inline* }
BlockCommentContent = @{
    ((!("*/" | "/*") ~ ANY) | BlockComment)* // allow nested comments
}

// Syntax from grammar.txt
Motoko = {
  Header ~ Program ~ EOI
}
Header = ${
  SOI
  ~ WHITESPACE*
  ~ (Comment ~ ShouldNewline)?
}
Program = {
  CompleteImport*
  ~ CompleteDeclaration*
}


CompleteImport = { Import ~ EndOfImport }
EndOfImport = ${ Semicolon ~ ShouldNewline }
EndOfDeclaration = ${
  ( Semicolon | EOI )
  ~ ShouldNewline
}

CompleteDeclaration = { Declaration ~ EndOfDeclaration }


InvalidPart = { (!Semicolon ~ ANY)+ ~ Semicolon?}

Semicolon = @{ ";" }
EqualSign = @{ "=" }
Colon = @{ ":" }

Keyword = @{
    ("actor" | "and" | "assert" | "async" | "await" | "break" | "case" | "catch" | "class" | "continue" | "debug"
    | "debug_show" | "do" | "else" | "flexible" | "false" | "for" | "from_candid" | "func" | "if" | "ignore" | "import"
    | "in" | "module" | "not" | "null" | "object" | "or" | "label" | "let" | "loop" | "private" | "public" | "query" | "return"
    | "shared" | "stable" | "switch" | "system" | "throw" | "to_candid" | "true" | "try" | "type" | "var" | "while"
    ) ~ !IdContinue
}
KeywordActor = @{"actor" ~ !IdContinue}
KeywordAnd = @{"and" ~ !IdContinue}
KeywordAssert = @{"assert" ~ !IdContinue}
KeywordAsync = @{"async" ~ !IdContinue}
KeywordAwait = @{"await" ~ !IdContinue}
KeywordBreak = @{"break" ~ !IdContinue}
KeywordCase = @{"case" ~ !IdContinue}
KeywordCatch = @{"catch" ~ !IdContinue}
KeywordClass = @{"class" ~ !IdContinue}
KeywordContinue = @{"continue" ~ !IdContinue}
KeywordDebug = @{"debug" ~ !IdContinue}
KeywordDebugShow = @{"debug_show" ~ !IdContinue}
KeywordDo = @{"do" ~ !IdContinue}
KeywordElse = @{"else" ~ !IdContinue}
KeywordFlexible = @{"flexible" ~ !IdContinue}
KeywordFalse = @{"false" ~ !IdContinue}
KeywordFor = @{"for" ~ !IdContinue}
KeywordFromCandid = @{"from_candid" ~ !IdContinue}
KeywordFunc = @{"func" ~ !IdContinue}
KeywordIf = @{"if" ~ !IdContinue}
KeywordIgnore = @{"ignore" ~ !IdContinue}
KeywordImport = @{"import" ~ !IdContinue}
KeywordIn = @{"in" ~ !IdContinue}
KeywordModule = @{"module" ~ !IdContinue}
KeywordNot = @{"not" ~ !IdContinue}
KeywordNull = @{"null" ~ !IdContinue}
KeywordObject = @{"object" ~ !IdContinue}
KeywordOr = @{"or" ~ !IdContinue}
KeywordLabel = @{"label" ~ !IdContinue}
KeywordLet = @{"let" ~ !IdContinue}
KeywordLoop = @{"loop" ~ !IdContinue}
KeywordPrivate = @{"private" ~ !IdContinue}
KeywordPublic = @{"public" ~ !IdContinue}
KeywordQuery = @{"query" ~ !IdContinue}
KeywordReturn = @{"return" ~ !IdContinue}
KeywordShared = @{"shared" ~ !IdContinue}
KeywordStable = @{"stable" ~ !IdContinue}
KeywordSwitch = @{"switch" ~ !IdContinue}
KeywordSystem = @{"system" ~ !IdContinue}
KeywordThrow = @{"throw" ~ !IdContinue}
KeywordToCandid = @{"to_candid" ~ !IdContinue}
KeywordTrue = @{"true" ~ !IdContinue}
KeywordTry = @{"try" ~ !IdContinue}
KeywordType = @{"type" ~ !IdContinue}
KeywordVar = @{"var" ~ !IdContinue}
KeywordWhile = @{"while" ~ !IdContinue}


// Imports
Import = { KeywordImport ~ PatternNullary ~ EqualSign? ~ Text }
PatternNullary = {
  "{" ~ /*List*/ (PatternField  ~ (Semicolon ~ PatternField)* ~ Semicolon?)? ~ "}"
  | PatternPlain
}
PatternField = {
  Id ~ (":" ~ Type)? ~ (EqualSign ~ Pattern)?
}
Pattern = { PatternBin }
PatternBin = {
  PatternUn ~ (KeywordOr ~ PatternBin)* ~ (":" ~ Type)* 
}
PatternPlain = {
  "_"
  | "(" ~ /*List*/(PatternField ~ (Semicolon ~ PatternField)* ~ Semicolon?)? ~ ")"
  | Lit
  | Id
}
PatternUn = {
  "#" ~ Id ~ PatternNullary?
  | "?" ~ PatternUn
  | UnOp ~ Lit
  | PatternNullary
}

UnOp = @{ "+" | "-" | "^" } 

Type = {
    TypeNoBin ~ KeywordAnd ~ Type
    | TypeNoBin ~ KeywordOr ~ Type
    | TypeNoBin
}

TypeNoBin = {
    FuncSort? ~ ("<" ~/*List*/(TypeBind ~ ("," ~ TypeBind)* ~ ","?)? ~ ">")? ~ TypeUn ~ "->" ~ TypeNoBin
    | TypePre
}

FuncSort = {
  KeywordShared ~ KeywordQuery?
  | KeywordQuery
}

TypePre = {
    "async" ~ TypePre
    | ObjSort ~ TypeObj
    | TypeUn
} 

ObjSort = { KeywordObject | KeywordActor | KeywordModule }

TypeBind = { Id ~ ("<:" ~ Type)? }

TypeUn = {
  "?" ~ TypeUn
  | TypeNullary
}

TypeNullary = {
    "(" ~ /*List*/(TypeItem ~ ("," ~ TypeItem)* ~ ","?)? ~ ")"
    | "[" ~ "var"? ~ Type ~ "]"
    | TypeVariant
    | TypeObj
    | Id ~ ("." ~ Id)* ~ TypeArgs?
} 
TypeItem = { (Id ~ ":")? ~ Type }

TypeVariant = {
    "{" ~ "#" ~ "}"
    | "{" ~ /*List1*/(TypeTag ~ (Semicolon ~ TypeTag)* ~ Semicolon?) ~ "}"
}

TypeObj = {
    "{" ~ /*List*/(TypeField ~ (Semicolon ~ TypeField)* ~ Semicolon?)? ~ "}"
} 

TypeTag = {
  "#" ~ Id ~ (":" ~ Type)?
}

TypeArgs = {
  "<" ~ /*List*/(Type ~ ("," ~ Type)* ~ ","?)? ~ ">"
}

TypeField = {
  "var"? ~ Id ~ ":" ~ Type
  | Id ~ TypeBindList? ~ TypeNullary ~ ":" ~ Type
}

TypeBindList = {
  "<" ~ /*List*/(TypeBind ~ ("," ~  TypeBind)* ~ ","?)? ~ ">"
}

Declaration = {
  ( DeclarationVar
  | DeclarationNonVar
  | ExpNonDec
  ) ~ COMMENT? // hack to collect all tailing whitespace and comments
}

DeclarationVar = {
  "var" ~ Id ~ (":" ~ Type)? ~ EqualSign ~ Exp
}

DeclarationNonVar = {
  "let" ~ Pattern ~ "=" ~ Exp
  | "type" ~ Id ~ TypeBindList? ~ EqualSign ~ Type
  | ObjSort ~ Id? ~ EqualSign? ~ ObjBody
  | SharedPattern? ~ "func" ~ Id? ~ TypeBindList? ~ PatternPlain ~ (":" ~ Type)? ~ FuncBody
  | SharedPattern2? ~ "func" ~ Id? ~ TypeBindList? ~ PatternPlain ~ (":" ~ Type)? ~ FuncBody
  | SharedPattern? ~ ObjSort? ~ "class" ~ Id?
    ~ ("<" ~ /*List*/(TypeBind ~ ("," ~ TypeBind)*)? ~ ","? ~ ">")?
    ~ PatternPlain ~ (":" ~ Type)? ~ ClassBody
  | SharedPattern2? ~ ObjSort? ~ "class" ~ Id?
    ~ ("<" ~ /*List*/(TypeBind ~ ("," ~ TypeBind)*)? ~ ","? ~ ">")?
    ~ PatternPlain ~ (":" ~ Type)? ~ ClassBody
}

ClassBody = {
  (EqualSign ~ Id?)? ~ ObjBody
}

SharedPattern = {
    "shared" ~ "query"? ~ PatternPlain?
    | "query" ~ PatternPlain
    | "query"
}
SharedPattern2 = {
    "shared" ~ "query"?
    | "query"
    | "query"
}

FuncBody = {
  "=" ~ Exp
  | Block
}

Block = {
  "{"
  ~ /*List*/(Declaration ~ (Semicolon ~ Declaration)* ~ Semicolon?)?
  ~ "}"
}

ObjBody = {
  "{"
  ~ /*List*/(DeclarationField ~ (Semicolon ~ DeclarationField)* ~ Semicolon?)?
  ~ "}"
}
DeclarationField = { Visibility? ~ Stability? ~ Declaration }
Visibility = { "private" | "public" | "system" }
Stability = { "flexible" | "stable" }

Exp = {
  ParenthesizedExp
  | DeclarationVar
  | ExpNonVar
}

// https://github.com/dfinity/motoko/blob/master/doc/modules/language-guide/pages/language-manual.adoc#parentheses
ParenthesizedExp = {
  "(" ~ Exp ~ ")"
}

ExpNonVar = {
  ExpNonDec
  | DeclarationNonVar
}

ExpNonDec = {
  "assert" ~ ExpNest
  | "async" ~ ExpNest
  | "await" ~ ExpNest
  | "break" ~ Id ~ ExpNullary?
  | "continue" ~ Id
  | "debug" ~ ExpNest
  | "do" ~ "?"? ~ Block
  | "for" ~ "(" ~ Pattern ~ "in" ~ Exp ~ ")" ~ ExpNest
  | "if" ~ ExpNullary ~ ExpNest ~ ("else" ~ ExpNest)?
  | "ignore" ~ ExpNest
  | "label" ~ Id ~ (":" ~ Type)? ~ ExpNest
  | "loop" ~ ExpNest ~ ("while" ~ ExpNest)?
  | KeywordReturn ~ Exp?
  | "switch" ~ ExpNullary ~ "{" ~ /*List*/(Case ~ (Semicolon ~ Case)* ~ Semicolon)? ~ "}"
  | "throw" ~ ExpNest
  | "try" ~ ExpNest ~ Catch
  | "while" ~ ExpNullary ~ ExpNest
  | ExpBin ~ ":=" ~ Exp
  | ExpBin ~ BinAssign ~ Exp
  | ExpBin
}

Case = {
  "case" ~ PatternNullary ~ ExpNest
}

Catch = {
  "catch" ~ PatternNullary ~ ExpNest
}

ExpNest = { Block | Exp }

BinAssign = @{
  "%="
  | "&="
  | "*%="
  | "**%="
  | "**-"
  | "*="
  | "+%="
  | "+="
  | "-%="
  | "-="
  | "/="
  | "<<="
  | "<<>="
  | "<>>="
  | ">>="
  | "@="
  | "^="
  | "|="
}

// Sample matches: Id, "[]"
ExpUn = {
    "?" ~ ExpUn
    | "actor" ~ ExpPlain
    | "not" ~ ExpUn
    | "debug_show" ~ ExpUn
    | "to_candid" ~ ExpList
    | "from_candid" ~ ExpUn
    | "#" ~ Id ~ ExpNullary?
    | UnOp ~ ExpUn
    | UnAssign ~ ExpUn
    | ExpPost
}

// Sample matches: Id, "[]", "{" Id "}", "{}", Id Id Id
ExpPost = {
  ("[" ~ "var"?
  ~ /*List*/(ExpNonVar ~ ("," ~ ExpNonVar)* ~ ","?)?
  ~ "]"
  | ExpNullary
  )
  ~ ExpPostContinue?
  ~ ("(" ~ ExpPostContinue? ~ ")")? // TODO!: not in spec! check!
}
ExpPostContinue = {
  ExpPost
  | "[" ~ Exp ~ "]"
  | "." ~ Nat
  | "." ~ Id
  | ("<" ~ /*List*/(Type ~("," ~ Type)* ~ ","?)? ~ ">")? ~ ExpNullary
  | BANG
}

BANG = @{ "!" }

// Sample matches: Id, "{" Id "}", "{}"
ExpNullary = {
  ExpObj | ExpPlain | Id
}

// Sample matches "{" Id "}"
ExpObj = {
  "{" ~ /*List*/(ExpField ~ (Semicolon ~ ExpField)* ~ Semicolon?)? ~ "}"
}

ExpField = {
  "var"? ~ Id ~ (":" ~Type)? ~ ("=" ~ Exp)?
}

UnAssign = { "+=" | "-=" | "^=" }

ExpList = {
  "(" ~ /*List*/(Exp ~ ("," ~ Exp)* ~ ","?)? ~ ")"
}

ExpPlain = {
  ExpList
  | Lit
}

ExpBin = {
  ExpUn ~ (
    "and" ~ ExpBin
    | "or" ~ ExpBin
    | ":" ~ ExpBin
    | BinOp ~ ExpBin
    | RelOp ~ ExpBin
  )?
}

RelOp = {
  "=="
  | "!="
  | "< " // can't match leading spaces
  | "<="
  | "> " // can't match leading spaces
  | ">="
}

BinOp = {
    "+"
    | "#"
    | "%"
    | "&"
    | "*"
    | "*%"
    | "**%"
    | "**"
    | "+%"
    | "-%"
    | "-"
    | "/"
    | "<<>"
    | "<<"
    | "<>>"
    | ">>" /* can't match leading space */
    | "^"
    | "|"
}

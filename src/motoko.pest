// helper
any_inline = {!NEWLINE ~ ANY}
space = {" " | "\t"}
EOL = {NEWLINE | EOI}

WHITESPACE = { ( space | NEWLINE ) }
COMMENT = { Comment }

// Syntax is follwing the documentation at github:
// https://github.com/dfinity/motoko/blob/master/doc/modules/language-guide/pages/language-manual.adoc

Motoko = {
    SOI ~ Prog ~ EOI
}

// comments

Comment = { DocComment | LineComment | BlockComment }

DocComment = { ("/// " ~ any_inline* ~ EOL)+ }

LineComment = { "//"  ~ any_inline* ~ EOL }


BlockComment = { 
    "/*"
    ~ ((!("*/" | "/*") ~ ANY) | BlockComment)* // allow nested comments
    ~ "*/"
}

// copy & pasted from
// https://github.com/dfinity/motoko/blob/master/doc/modules/language-guide/pages/language-manual.adoc#keywords=
Keyword = {
    "actor" | "and" | "assert" | "async" | "await" | "break" | "case" | "catch" | "class" | "continue" | "debug"
    | "debug_show" | "do" | "else" | "flexible" | "false" | "for" | "from_candid" | "func" | "if" | "ignore" | "import"
    | "in" | "module" | "not" | "null" | "object" | "or" | "label" | "let" | "loop" | "private" | "public" | "query" | "return"
    | "shared" | "stable" | "switch" | "system" | "throw" | "to_candid" | "true" | "try" | "type" | "var" | "while"
}

Id = @{ ASCII_ALPHA ~ ( ASCII_ALPHANUMERIC | "_" )* }

Nat = ${ "0x" ~ HexNum | Num }
Num = @{ ASCII_DIGIT ~ ( "_"? ~ ASCII_DIGIT )* }
HexNum = @{ ASCII_HEX_DIGIT ~ ( "_"? ~ ASCII_HEX_DIGIT )* }
Sign = @{ "-" }

Frac = @{ Num }
HexFrac = @{ HexNum }
Float = @{
  Num ~ "." ~ Frac?
  | Num ~ ("." ~ Frac?)? ~ ("e" | "E") ~ Sign? ~ Num
  | HexNum ~ "." ~ HexFrac?
  | "0x" ~ HexNum ~ ("." ~ HexFrac?)? ~ ("p" | "P") ~ Sign? ~ Num
}

Escape = { "n" | "r" | "t" | "\\" | "\'" | "\"" }


Character = @{ 
    "\\" ~ Escape
    | "\\" ~ ASCII_HEX_DIGIT ~ ASCII_HEX_DIGIT
    | "\\{" ~ HexNum ~ "}"
    | !("\\") ~ any_inline
}

Char = @{ "'" ~ (!"'" ~ Character) ~ "'" }
Text = @{ "\"" ~ (!"\"" ~ Character)* ~ "\"" } // TODO: check "'" and '"' and ''' and """ in motoko

Lit = ${ Float | Nat | Char | Text }

// Operators

UnOp = @{ "-" | "+" | "^" | "!" }
RelOp = @{ "==" | "!=" | space ~ "<" ~ space | space ~ ">" ~ space | "<=" | ">=" } // 
BinOp = @{ "+" | "-" | "*" | "/" | "%" | "**"
    | "#"
}
BitOp = @{
    "&" | "|" | "^" | "<<" | space ~ ">>" | "<<>" | "<>>" | "+%" | "-%" | "*%" | "**%"
}
Assignment = @{
    ":=" | "+=" | "-=" | "*=" | "/=" | "%=" | "**=" | "&=" | "|=" | "^=" 
    | "<<=" | ">>=" | "<<>=" | "<>>=" | "+%=" | "-%=" | "**%=" | "#="
}

// Programs
Prog = { (Imp ~ ";")* ~ (Exp ~ ";")* }

Imp = {"import" ~ Pat ~ "="? ~ Url}

Url = @{
    Text
}

Function = {
    (SharedPat ~ space)? ~ "func" ~ Id? ~ TypParams? ~ Pat ~ (":" ~ Typ)? ~ "=?" ~ Exp
}

ObjBody = { "{" ~ (DecField ~ ";")* ~ "}" }

ClassBody = { ("=" ~ Id)? ~ ObjBody }

SharedPat = { "shared" ~ "query"? ~ Pat? }

DecField = { Vis? ~ Stab? ~ Exp }

Vis = { "public" | "private" | "system" }

Stab = { "stable" | "flexible" }

Exp = {
  BaseExp ~ BinOp ~ Exp
  | BaseExp ~ RelOp ~ Exp
  | BaseExp ~ "." ~ Nat
  | BaseExp ~ "." ~ Id
  | BaseExp ~ ":=" ~ Exp
  | BaseExp ~ "[" ~ Exp ~ "]"
  | BaseExp ~ TypArgs? ~ Exp
  | BaseExp ~ "and" ~ Exp
  | BaseExp ~ "or" ~ Exp
  | BaseExp ~ ":" ~ Typ
  | BaseExp ~ "!"
  | BaseExp
}

BaseExp = {
  "(" ~ (Exp ~ ("," ~ Exp)*)? ~ ")"
  | "?" ~ Exp
  | "{" ~ (ExpField ~ ";")* ~ "}"
  | "# id" ~ Exp?
  | "[" ~ space* ~ "var"? ~ (Exp ~ ",")* ~ "]"
  | "not" ~ Exp
  | "if" ~ Exp ~ BlockOrExp ~ ("else" ~ BlockOrExp)?
  | "switch" ~ Exp ~ "{" ~ ("case" ~ Pat ~ BlockOrExp ~ ";")+ ~ "}"
  | "while" ~ Exp ~ BlockOrExp
  | "loop" ~ BlockOrExp ~ ("while" ~ Exp)?
  | "for" ~ ( Pat ~ "in" ~ Exp ) ~ BlockOrExp
  | "label" ~ Id ~ (":" ~ Typ)? ~ BlockOrExp
  | "break" ~ Id ~ Exp?
  | "continue" ~ Id
  | "return" ~ Exp?
  | "async" ~ BlockOrExp
  | "await" ~ BlockOrExp
  | "throw" ~ Exp
  | "try" ~ BlockOrExp ~ "catch" ~ Pat ~ BlockOrExp
  | "assert" ~ BlockOrExp
  | "ignore" ~ BlockOrExp
  | "do" ~ Block
  | "do" ~ "?" ~ Block
  | "debug" ~ BlockOrExp
  | "actor" ~ Exp
  | "to_candid" ~ "(" ~ (Exp ~ ",")* ~ ")"
  | "from_candid" ~ Exp
  | "(" ~ Exp ~ ")"
  | "let" ~ Pat ~ "=" ~ Exp
  | "var" ~ Id ~ (":" ~ Typ)? ~ "=" ~ Exp
  | "type" ~ space ~ Id ~ (space ~ TypParams)? ~ "=" ~ Typ
  | UnOp ~ "=" ~ Exp
  | Function
  | SharedPat? ~ Sort? ~ "class" ~ Id? ~ TypParams? ~ Pat ~ (":" ~ Typ)? ~ ClassBody
  | Sort ~ Id? ~ "="? ~ ObjBody
  | SharedPat? ~ "func" ~ FuncExp
  | Lit
  | UnOp ~ Exp
  //TODO: maual ids for testing
  | ("name" | "Stack")
 // | Id
}


BlockOrExp = { Block | Exp }

Block = { "{" ~ (Exp ~ ";")* ~ "}" }


Pat = {
  BasePat
  | BasePat ~ ":" ~ Typ
  | BasePat ~ "or" ~ Pat
}

BasePat = {
  "_"
  | "(" ~ (Pat ~ ",")* ~ ")"
  | "{" ~ PatField ~ ";"* ~ "}"
  | "#" ~ Id ~ Pat? 
  | "?" ~ Pat
  | UnOp? ~ Lit
  | Id

}

PatField = {
  Id ~ "(:" ~ Typ ~ ")" ~ "=" ~ Pat
  | Id ~ "(:" ~ Typ ~ ")"
}


Typ = {
  BaseTyp
  | BaseTyp ~ "and" ~ Typ
  | BaseTyp ~ "or" ~ Typ
  | BaseTyp ~ "->" ~ Typ
}

BaseTyp = {
  "{" ~ (TypTag ~ (";" ~ TypTag)*)? ~ "}"
  | "{" ~ "#" ~ "}"
  | "[" ~ "var"? ~ Typ ~ "]"
  | "Null"
  | "?" ~ Typ
  | "async" ~ Typ
  | "(" ~ ((Id ~ ":")? ~ Typ ~ ",")* ~ ")"
  | "Any"
  | "None"
  | "Error"
  | "(" ~ Typ ~ ")"
  | Sort? ~ "{" ~ (TypField ~ ";")* ~ "}"
  | TypParams ~ Typ ~ "->" ~ Typ
  | Shared ~ TypParams? ~ Typ ~ "->" ~ Typ
  | Path ~ TypArgs?
}

Sort = { "actor" | "module" | "object" }

Shared = { "shared" ~ space+ ~ "query"? }

Path = { (Id ~ ".")* ~ Id }

Bool = { "true" | "false" }


TypField = {
    Id ~ ":" ~ Typ
    | "var" ~ Id ~ ":" ~ Typ
    | Id ~ TypParams? ~ Typ ~ ":" ~ Typ
}

TypTag = {
    Id ~ ":" ~ Typ
    | Id
}

TypParams = {
    TypParam ~ ("," ~ TypParam)*
}

TypParam = {
    Id ~ ":" ~ Typ
    | Id
}

TypArgs = { "<" ~ Typ ~ ("," ~ Typ)* ~ ">"}

ExpField = {
    "var"? ~ Id ~ (":" ~ Typ) ~ "=" ~ Exp
    | "var"? ~ Id ~ (":" ~ Typ)
}

FuncExp = {
    //https://github.com/dfinity/motoko/blob/33278441c0eca523068c623881b690709af58197/src/mo_frontend/parser.mly#L122=
    Id ~ "(" ~ (TypParam ~ ("," ~ TypParam)*)? ~ ")" ~ ":" ~ Typ ~ Block
}